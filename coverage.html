
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/TommyStarK/claptrap/claptrap.go (60.0%)</option>
				
				<option value="file1">github.com/TommyStarK/claptrap/event.go (100.0%)</option>
				
				<option value="file2">github.com/TommyStarK/claptrap/main.go (16.7%)</option>
				
				<option value="file3">github.com/TommyStarK/claptrap/utils.go (100.0%)</option>
				
				<option value="file4">github.com/TommyStarK/claptrap/watcher.go (84.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "os"
        "os/signal"
        "sync/atomic"
        "syscall"
)

type claptrap struct {
        config  *config
        events  chan *event
        watcher *watcher

        clapMustStop uint32
        errors       chan error
        sigchan      chan os.Signal
        testMode     bool
}

func newClaptrap(cfg *config) (*claptrap, error) <span class="cov10" title="2">{
        errors := make(chan error)
        events := make(chan *event)
        sigchan := make(chan os.Signal, 1)

        signal.Notify(sigchan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGKILL)

        w, err := newWatcher(cfg.path, events, errors)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var c = &amp;claptrap{
                config:  cfg,
                events:  events,
                watcher: w,

                clapMustStop: 0,
                errors:       errors,
                sigchan:      sigchan,
                testMode:     false,
        }

        return c, nil</span>
}

func (c *claptrap) clap(event *event) <span class="cov0" title="0">{
        if atomic.LoadUint32(&amp;c.clapMustStop) == 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Printf("claptrap event on: %s", event.name)
        for fsnotifyEventType, timestamp := range event.trace </span><span class="cov0" title="0">{
                log.Printf("-------&gt; Type: %s  @@@  %s", fsnotifyEventType.String(), timestamp)
        }</span>
}

func (c *claptrap) trap() <span class="cov1" title="1">{
        go c.watcher.watch()

        for </span><span class="cov1" title="1">{
                select </span>{
                case sig, ok := &lt;-c.sigchan:<span class="cov1" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                os.Exit(1)
                                return
                        }</span>

                        <span class="cov1" title="1">atomic.StoreUint32(&amp;c.clapMustStop, 1)

                        if err := c.watcher.stop(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to gracefully stop the watcher: %s", err.Error())
                        }</span>

                        <span class="cov1" title="1">close(c.sigchan)
                        close(c.errors)
                        close(c.events)

                        log.Println("claptrap exiting ...")

                        if c.testMode </span><span class="cov1" title="1">{
                                return
                        }</span>

                        <span class="cov0" title="0">os.Exit(convertSignalToInt(sig))
                        return</span>

                case event, ok := &lt;-c.events:<span class="cov0" title="0">
                        if ok &amp;&amp; event != nil </span><span class="cov0" title="0">{
                                go c.clap(event)
                        }</span>

                case err, ok := &lt;-c.errors:<span class="cov0" title="0">
                        if ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                                log.Println("error: ", err)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "sync"

        "github.com/fsnotify/fsnotify"
)

type event struct {
        mutex sync.Mutex

        name  string
        trace map[fsnotify.Op]string
}

func (e *event) chmod(timestamp string) <span class="cov4" title="3">{
        e.mutex.Lock()
        e.trace[fsnotify.Chmod] = timestamp
        e.mutex.Unlock()
}</span>

func (e *event) create(timestamp string) <span class="cov4" title="3">{
        e.mutex.Lock()
        e.trace[fsnotify.Create] = timestamp
        e.mutex.Unlock()
}</span>

func (e *event) remove(timestamp string) <span class="cov3" title="2">{
        e.mutex.Lock()
        e.trace[fsnotify.Remove] = timestamp
        e.mutex.Unlock()
}</span>

func (e *event) rename(timestamp string) <span class="cov3" title="2">{
        e.mutex.Lock()
        e.trace[fsnotify.Rename] = timestamp
        e.mutex.Unlock()
}</span>

func (e *event) write(timestamp string) <span class="cov3" title="2">{
        e.mutex.Lock()
        e.trace[fsnotify.Write] = timestamp
        e.mutex.Unlock()
}</span>

func (e *event) isReadyForBeingProcessed() bool <span class="cov9" title="11">{
        e.mutex.Lock()
        timestamp, ok := e.trace[fsnotify.Remove]
        e.mutex.Unlock()

        if ok &amp;&amp; len(timestamp) &gt; 0 </span><span class="cov3" title="2">{
                return true
        }</span>

        <span class="cov8" title="9">e.mutex.Lock()
        timestamp, ok = e.trace[fsnotify.Rename]
        e.mutex.Unlock()

        if ok &amp;&amp; len(timestamp) &gt; 0 </span><span class="cov3" title="2">{
                return true
        }</span>

        <span class="cov7" title="7">var witness fsnotify.Op
        e.mutex.Lock()
        for k, v := range e.trace </span><span class="cov10" title="14">{
                if len(v) &gt; 0 </span><span class="cov10" title="14">{
                        witness = witness | k
                }</span>
        }
        <span class="cov7" title="7">e.mutex.Unlock()

        if witness&amp;fsnotify.Write != 0 &amp;&amp; witness&amp;fsnotify.Chmod != 0 </span><span class="cov3" title="2">{
                return true
        }</span>

        <span class="cov6" title="5">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import "log"

func init() <span class="cov8" title="1">{
        log.Println("init")
}</span>

func main() <span class="cov0" title="0">{
        var cfg = &amp;config{
                path: ".",
        }

        app, err := newClaptrap(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">app.trap()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "os"
        "regexp"
        "strings"
)

var parseYAMLRegexHandler = regexp.MustCompile(`(?m)\[(.+)\]=\[(.+)\]`)

func convertSignalToInt(sig os.Signal) (rc int) <span class="cov10" title="4">{
        rc = 1

        if sig == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov8" title="3">switch sig.String() </span>{
        case os.Interrupt.String():<span class="cov1" title="1">
                rc = 2</span>
        case os.Kill.String():<span class="cov1" title="1">
                rc = 9</span>
        case "terminated":<span class="cov1" title="1">
                rc = 15</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov8" title="3">return</span>
}

func extractKeyValueFromStringFormatedForClaptrapYAMLConfigFile(target string) (key, value string) <span class="cov10" title="4">{
        matches := parseYAMLRegexHandler.FindStringSubmatch(target)

        if len(matches) != 3 </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov8" title="3">matches = matches[1:]
        key = strings.TrimSpace(matches[0])
        value = strings.TrimSpace(matches[1])
        return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "errors"
        "log"
        "sync"
        "sync/atomic"
        "time"

        "github.com/fsnotify/fsnotify"
)

type watcher struct {
        events     chan *event
        fsnWatcher *fsnotify.Watcher
        trace      map[string]*event

        errs               chan error
        processingMustStop uint32
        rwmutex            sync.RWMutex
        stopWatching       chan chan struct{}
}

func newWatcher(path string, events chan *event, errs chan error) (*watcher, error) <span class="cov8" title="7">{
        if len(path) == 0 </span><span class="cov1" title="1">{
                return nil, errors.New("watcher: invalid path, received empty string")
        }</span>

        <span class="cov8" title="6">if events == nil </span><span class="cov1" title="1">{
                return nil, errors.New("watcher: invalid events channel, received nil")
        }</span>

        <span class="cov7" title="5">if errs == nil </span><span class="cov1" title="1">{
                return nil, errors.New("watcher: invalid errors channel, received nil")
        }</span>

        <span class="cov6" title="4">fsnWatcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="4">if err := fsnWatcher.Add(path); err != nil </span><span class="cov3" title="2">{
                defer func() </span><span class="cov3" title="2">{
                        if err := fsnWatcher.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("failed to close fsnotify watcher: %s", err.Error())
                        }</span>
                }()

                <span class="cov3" title="2">return nil, err</span>
        }

        <span class="cov3" title="2">var w = &amp;watcher{
                events:     events,
                fsnWatcher: fsnWatcher,
                trace:      make(map[string]*event),

                errs:               errs,
                rwmutex:            sync.RWMutex{},
                processingMustStop: 0,
                stopWatching:       make(chan chan struct{}),
        }

        return w, nil</span>
}

func (w *watcher) processEvent(fsevent fsnotify.Event) <span class="cov8" title="7">{
        var (
                exist       bool
                targetEvent *event
                timestamp   string = time.Now().UTC().String()
        )

        w.rwmutex.RLock()
        targetEvent, exist = w.trace[fsevent.Name]
        w.rwmutex.RUnlock()

        if atomic.LoadUint32(&amp;w.processingMustStop) == 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="7">if !exist </span><span class="cov5" title="3">{
                var newEvent = &amp;event{
                        mutex: sync.Mutex{},
                        name:  fsevent.Name,
                        trace: make(map[fsnotify.Op]string),
                }

                targetEvent = newEvent
                w.rwmutex.Lock()
                w.trace[fsevent.Name] = targetEvent
                w.rwmutex.Unlock()
        }</span>

        <span class="cov8" title="7">switch fsevent.Op </span>{
        case fsnotify.Create:<span class="cov3" title="2">
                targetEvent.create(timestamp)</span>
        case fsnotify.Write:<span class="cov1" title="1">
                targetEvent.write(timestamp)</span>
        case fsnotify.Remove:<span class="cov1" title="1">
                targetEvent.remove(timestamp)</span>
        case fsnotify.Rename:<span class="cov1" title="1">
                targetEvent.rename(timestamp)</span>
        case fsnotify.Chmod:<span class="cov3" title="2">
                targetEvent.chmod(timestamp)</span>
        }

        <span class="cov8" title="7">if targetEvent.isReadyForBeingProcessed() &amp;&amp; atomic.LoadUint32(&amp;w.processingMustStop) == 0 </span><span class="cov5" title="3">{
                w.rwmutex.Lock()
                w.events &lt;- targetEvent
                delete(w.trace, targetEvent.name)
                w.rwmutex.Unlock()
        }</span>

        <span class="cov8" title="7">return</span>
}

func (w *watcher) stop() error <span class="cov3" title="2">{
        atomic.StoreUint32(&amp;w.processingMustStop, 1)
        ch := make(chan struct{})
        w.stopWatching &lt;- ch
        &lt;-ch
        close(ch)
        close(w.stopWatching)
        return w.fsnWatcher.Close()
}</span>

func (w *watcher) watch() <span class="cov3" title="2">{
        for </span><span class="cov10" title="9">{
                select </span>{
                case ch := &lt;-w.stopWatching:<span class="cov3" title="2">
                        ch &lt;- struct{}{}
                        return</span>

                case e, ok := &lt;-w.fsnWatcher.Events:<span class="cov8" title="7">
                        if !ok </span><span class="cov0" title="0">{
                                w.events &lt;- nil
                                return
                        }</span>

                        <span class="cov8" title="7">go w.processEvent(e)</span>

                case err, ok := &lt;-w.fsnWatcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                w.errs &lt;- nil
                                return
                        }</span>

                        <span class="cov0" title="0">w.errs &lt;- err</span>
                }
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
